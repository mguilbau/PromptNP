/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "RooNA60.h"

#include <RooAbsReal.h>
#include <RooAbsCategory.h>

#include <Riostream.h>
#include <TMath.h>

#include <cmath>

ClassImp(RooNA60);

RooNA60::RooNA60(const char *name, const char *title,
                        RooAbsReal& _m,
                        RooAbsReal& _m0,
                        RooAbsReal& _sigma,
                        RooAbsReal& _alpha,
                        RooAbsReal& _p1,
                        RooAbsReal& _p2,
                        RooAbsReal& _p3,
                        RooAbsReal& _alpha2,
                        RooAbsReal& _p12,
                        RooAbsReal& _p22,
                        RooAbsReal& _p32)
   : RooAbsPdf(name,title),
   m("m","m",this,_m),
   m0("m0","m0",this,_m0),
   sigma("sigma","sigma",this,_sigma),
   alpha("alpha","alpha",this,_alpha),
   p1("p1","p1",this,_p1),
   p2("p2","p2",this,_p2),
   p3("p3","p3",this,_p3),
   alpha2("alpha2","alpha2",this,_alpha2),
   p12("p12","p12",this,_p12),
   p22("p22","p22",this,_p22),
   p32("p32","p32",this,_p32)
{
}

RooNA60::RooNA60(RooNA60 const &other, const char *name)
   : RooAbsPdf(other,name),
   m("m",this,other.m),
   m0("m0",this,other.m0),
   sigma("sigma",this,other.sigma),
   alpha("alpha",this,other.alpha),
   p1("p1",this,other.p1),
   p2("p2",this,other.p2),
   p3("p3",this,other.p3),
   alpha2("alpha2",this,other.alpha2),
   p12("p12",this,other.p12),
   p22("p22",this,other.p22),
   p32("p32",this,other.p32)
{
}


double RooNA60::evaluate() const 
{
   return RooNA60_evaluate(m, m0, sigma, alpha, p1, p2, p3, alpha2, p12, p22, p32); 
}

void RooNA60::computeBatch(double *output, std::size_t size, RooFit::Detail::DataMap const &dataMap) const 
{ 
   std::span<const double> mSpan = dataMap.at(m);
   std::span<const double> m0Span = dataMap.at(m0);
   std::span<const double> sigmaSpan = dataMap.at(sigma);
   std::span<const double> alphaSpan = dataMap.at(alpha);
   std::span<const double> p1Span = dataMap.at(p1);
   std::span<const double> p2Span = dataMap.at(p2);
   std::span<const double> p3Span = dataMap.at(p3);
   std::span<const double> alpha2Span = dataMap.at(alpha2);
   std::span<const double> p12Span = dataMap.at(p12);
   std::span<const double> p22Span = dataMap.at(p22);
   std::span<const double> p32Span = dataMap.at(p32);

   for (std::size_t i = 0; i < size; ++i) {
      output[i] = RooNA60_evaluate(mSpan.size() > 1 ? mSpan[i] : mSpan[0],
                               m0Span.size() > 1 ? m0Span[i] : m0Span[0],
                               sigmaSpan.size() > 1 ? sigmaSpan[i] : sigmaSpan[0],
                               alphaSpan.size() > 1 ? alphaSpan[i] : alphaSpan[0],
                               p1Span.size() > 1 ? p1Span[i] : p1Span[0],
                               p2Span.size() > 1 ? p2Span[i] : p2Span[0],
                               p3Span.size() > 1 ? p3Span[i] : p3Span[0],
                               alpha2Span.size() > 1 ? alpha2Span[i] : alpha2Span[0],
                               p12Span.size() > 1 ? p12Span[i] : p12Span[0],
                               p22Span.size() > 1 ? p22Span[i] : p22Span[0],
                               p32Span.size() > 1 ? p32Span[i] : p32Span[0]);
   }
} 
void RooNA60::translate(RooFit::Detail::CodeSquashContext &ctx) const
{
   ctx.addResult(this, ctx.buildCall("RooNA60_evaluate", m, m0, sigma, alpha, p1, p2, p3, alpha2, p12, p22, p32));
}
